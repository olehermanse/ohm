<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ohm</title>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Varela+Round" rel="stylesheet" />
    <style type="text/css">
      * {
        margin: 0;
        padding: 0;
        font-family: "Varela Round", Helvetica, Arial, Sans-Serif;
      }

      html {
        display: flex;
      }

      body {
        background-color: #f2f2f2;
        display: flex;
        min-height: 100vh;
      }

      h1 {
        font-size: 1.5em;
      }

      /* Link inside h1 (ohm logo/title) */
      h1 > a {
        /* Make link have no special style, normal color and no underline: */
        color: inherit;
        text-decoration: none;
      }

      .sidebar {
        height: 100vh;
        min-height: 600px;
        min-width: 90px;
        background-color: #ececec;
        color: #4a4a4a;
        display: flex;
        flex-direction: column;
      }

      .sidebar_content {
        height: 100%;
        display: flex;
        flex-direction: column;
      }

      .toolheader {
        flex: 0 1 auto;
        margin: auto;
        margin-top: 1em;
      }

      .toolbox {
        flex: 1 1 auto;
        display: flex;
        flex-direction: column;
        margin: auto;
        margin-top: 1em;
        margin-bottom: 1em;
      }

      .tool {
        flex: 1 1 auto;
        min-width: 36;
        height: 36;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .tool > div {
        padding: 1em;
      }

      .active_tool {
        color: blue;
      }

      /* The tool svg icons, or text divs when offline: */
      .tool_icon {
        min-width: 28;
        height: 28;
        text-align: center;
      }

      .tool_icon:hover {
        cursor: pointer;
      }

      /* Only if feather replaced tools with svg: */
      svg.tool_icon:hover {
        /* Tool icons grow bigger on hover: */
        min-width: 36;
        height: 36;
      }

      /* Tools are div when offline: */
      div.tool_icon:hover {
        /* The size of the sidebar is based on the biggest element,
            thus, use italic for feedback since it doesn't change width: */
        font-style: italic;
      }

      /* SVG styling:

         Should only be done in CSS for temporary styling while editing,
         so, coloring red for delete and blue for temp is okay,
         but setting stroke-width etc. should be done on the SVG nodes from
         javascript, and not in CSS. This is to ensure that the SVG looks
         identical once you hit save.
      */
      .delete {
        stroke: red;
      }

      circle#ohm_dot.delete {
        fill: red;
      }

      .copy {
        stroke: green;
      }

      circle#ohm_dot.copy {
        fill: green;
      }

      .tmp {
        stroke: blue;
      }

      circle#ohm_dot.tmp {
        fill: blue;
      }

      #drawing {
        background-color: #ffffff;
        border: 2px;
        border-color: #4a4a4a;
        margin: 1em;
      }

      #grid_line_major {
        stroke: rgb(200, 200, 200);
        stroke-width: 0.4;
      }

      #grid_line_minor {
        stroke: rgb(200, 200, 200);
        stroke-width: 0.2;
      }
    </style>
    <script>
      // Global state:
      var active_tool = "wire";
      var GRID_SIZE = 60;
      var grid_size = GRID_SIZE;
      var translation = null;
      var mouse = null;

      function init_ohm() {
        document.onkeydown = key_down;

        var p = document.getElementById("drawing");
        p.onmousedown = drawing_mouse_down;
        p.onmouseup = drawing_mouse_up;
        p.onmousemove = drawing_mouse_move;
        refresh_grid_lines();
        activate_tool(active_tool);
      }

      function activate_tool(new_state) {
        clear_temporary_elements();
        unselect_elements();
        active_tool = new_state;
        var toolbox = document.getElementById("toolbox");
        for (let tool of toolbox.children) {
          if (tool.id === active_tool) {
            tool.classList.add("active_tool");
          } else {
            tool.classList.remove("active_tool");
          }
        }
      }

      // Grid functions:

      function round_to_grid(pos) {
        return Math.round(pos / grid_size) * grid_size;
      }

      function get_grid_flavor(xy) {
        if (Math.round(xy) % GRID_SIZE === 0) {
          return "major";
        }
        return "minor";
      }

      function init_grid() {
        var drawing = document.getElementById("drawing");
        var svg_width = Number(drawing.getAttribute("width"));
        var svg_height = Number(drawing.getAttribute("height"));
        for (var x = grid_size; x < svg_width; x += grid_size) {
          create_grid_line(x, 0, x, svg_width, get_grid_flavor(x));
        }
        for (var y = grid_size; y < svg_height; y += grid_size) {
          create_grid_line(0, y, svg_height, y, get_grid_flavor(y));
        }
      }

      function num_to_string(num) {
        var str = "" + num;
        if (!str.includes(".")) {
          return str;
        }
        str = num.toFixed(2);
        while (str[str.length - 1] === "0") {
          str = str.slice(0, length - 1);
        }
        return str;
      }

      function create_grid_line(x1, y1, x2, y2, flavor) {
        var drawing = document.getElementById("drawing");
        var line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", num_to_string(x1));
        line.setAttribute("y1", num_to_string(y1));
        line.setAttribute("x2", num_to_string(x2));
        line.setAttribute("y2", num_to_string(y2));
        line.setAttribute("id", "grid_line_" + flavor);

        drawing.prepend(line);
      }

      function remove_grid_lines(drawing) {
        while (drawing.getElementById("grid_line_major")) {
          drawing.getElementById("grid_line_major").remove();
        }
        while (drawing.getElementById("grid_line_minor")) {
          drawing.getElementById("grid_line_minor").remove();
        }
      }

      function refresh_grid_lines() {
        var drawing = document.getElementById("drawing");
        remove_grid_lines(drawing);
        init_grid();
      }

      function resize(operation) {
        var drawing = document.getElementById("drawing");
        var svg_width = Number(drawing.getAttribute("width"));
        var svg_height = Number(drawing.getAttribute("height"));
        if (operation === "+") {
          svg_width += grid_size;
          svg_height += grid_size;
        } else if (operation === "-") {
          svg_width -= grid_size;
          svg_height -= grid_size;
        } else {
          console.log("Error: bad resize - " + operation);
        }
        drawing.setAttribute("width", "" + svg_width);
        drawing.setAttribute("height", "" + svg_height);

        refresh_grid_lines();
      }

      function subdivide_grid(operation) {
        var drawing = document.getElementById("drawing");
        grid_size = GRID_SIZE / operation;
        refresh_grid_lines();
      }

      // General functions for manipulating the svg drawing:
      // (Selecting, adding, removing)

      function get_elements_by_class(class_name) {
        var drawing = document.getElementById("drawing");
        return drawing.getElementsByClassName(class_name);
      }

      function get_temporary_elements() {
        return get_elements_by_class("tmp");
      }

      function clear_temporary_elements() {
        var temps = get_temporary_elements();
        for (let element of temps) {
          element.remove();
        }
      }

      function add_temporary_element(element) {
        element.classList.add("tmp");
        var drawing = document.getElementById("drawing");

        if (element.tagName === "circle") {
          // Circles and dots are appended at the end:
          drawing.appendChild(element);
        } else {
          // Others are inserted before the circles / dots:
          var firstCircle = drawing.getElementsByTagName("circle")[0];
          drawing.insertBefore(element, firstCircle);
        }
      }

      function place_temporary_elements() {
        var temps = get_temporary_elements();
        for (let element of temps) {
          element.classList.remove("tmp");
        }
      }

      // Copy and delete tools select elements inside svg using classes (coloring them)
      // This function removes those classes, for example when switching tool
      function unselect_elements() {
        var drawing = document.getElementById("drawing");
        for (let element of drawing.children) {
          element.classList.remove("copy");
          element.classList.remove("delete");
          // tmp should be removed using place_temporary_elements() or clear_temporary_elements()
        }
      }

      function hovered_elements(event) {
        // Returns a list of 0-1 elements that mouse is currently hovering over
        // Can be expanded to add elements below the top element later
        var elements = [];
        var element = event.target;
        if (element) {
          if (
            element.tagName === "circle" ||
            element.tagName === "polyline" ||
            element.tagName === "polygon"
          ) {
            elements.push(element);
          } // Skip other tags; "line" is used for grid lines
        }

        return elements;
      }

      function set_class_for_hovered(event, class_name) {
        var hovered = hovered_elements(event);
        var drawing = document.getElementById("drawing");

        for (let element of drawing.children) {
          if (hovered.includes(element)) {
            element.classList.add(class_name);
          } else {
            element.classList.remove(class_name);
          }
        }
      }

      // Mouse events:

      function update_mouse(event) {
        mouse = { target: null, offsetX: event.offsetX, offsetY: event.offsetY };
      }

      function fake_mouse_move() {
        if (mouse != null) {
          drawing_mouse_move(mouse);
        }
      }

      function drawing_mouse_down(event) {
        update_mouse(event);
        x = "" + round_to_grid(event.offsetX);
        y = "" + round_to_grid(event.offsetY);
        if (active_tool === "dot") {
          remove_circle(x, y); // (If it exists)
          place_temporary_elements();

          // Create temporary element immediately, don't wait for mouse movement:
          fake_mouse_move();
        } else if (active_tool === "wire") {
          drawing_wire_mouse_down(x, y);
        } else if (active_tool === "delete") {
          drawing_delete_mouse_down(event);
        } else if (active_tool === "copy") {
          drawing_copy_mouse_down(event);
        }
      }

      function drawing_mouse_up(event) {
        update_mouse(event);
        var x = "" + round_to_grid(event.offsetX);
        var y = "" + round_to_grid(event.offsetY);
        if (active_tool === "circle") {
          place_temporary_elements();

          // Create temporary circle immediately, don't wait for mouse movement:
          fake_mouse_move();
        }
      }

      function drawing_mouse_move(event) {
        update_mouse(event);
        var mouse_pressed = event.buttons > 0;
        var x = "" + round_to_grid(event.offsetX);
        var y = "" + round_to_grid(event.offsetY);
        if (active_tool === "wire") {
          drawing_wire_hover(x, y);
        } else if (active_tool === "delete") {
          drawing_delete_hover(event);
        } else if (active_tool === "copy") {
          drawing_copy_hover(event);
        } else if (active_tool === "dot") {
          drawing_dot_hover(x, y);
        } else if (active_tool === "circle" && !mouse_pressed) {
          drawing_circle_hover(x, y);
        } else if (active_tool === "circle" && mouse_pressed) {
          drawing_circle_drag(x, y);
        }
      }

      // Keyboard events:

      function key_down(event) {
        if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) {
          return;
        }
        var key = event.key;
        switch (key) {
          case "+":
          case "-":
            resize(key);
            break;
          case "1":
          case "2":
          case "3":
          case "4":
            subdivide_grid(key);
            break;
          case "Escape":
            clear_temporary_elements();
            unselect_elements();
            break;
          case "s":
            save();
            break;
          case "w":
          case "p":
            activate_tool("wire");
            break;
          case "c":
            activate_tool("circle");
            break;
          case "d":
            activate_tool("dot");
            break;
          case "e":
            activate_tool("delete");
            break;
        }
        fake_mouse_move();
      }

      // Functionality related to the left toolbar:

      function toolbar(icon_name) {
        clear_temporary_elements();
        if (icon_name === "save") {
          save();
        } else if (icon_name == "load") {
          load();
        } else {
          activate_tool(icon_name);
        }
      }

      function save() {
        clear_temporary_elements();
        var copy = document.getElementById("drawing").cloneNode(true);
        remove_grid_lines(copy);
        for (let element of copy.children) {
          element.removeAttribute("id");
          element.removeAttribute("class");
        }
        copy.removeAttribute("class");
        var svg_text = copy.outerHTML;
        download("schematic.svg", svg_text);
      }

      function load_svg(content) {
        var drawing = document.getElementById("drawing");
        drawing.outerHTML = content;
        init_ohm();
      }

      // https://stackoverflow.com/questions/16215771/
      function open_file_dialog(on_complete) {
        var input = document.createElement("input");
        input.type = "file";
        input.onchange = e => {
          var file = e.target.files[0];
          var reader = new FileReader();
          reader.readAsText(file, "UTF-8");
          reader.onload = readerEvent => {
            var content = readerEvent.target.result;
            on_complete(content);
          };
        };
        input.click();
      }

      function load() {
        open_file_dialog(load_svg);
      }

      // Save to file (using browser download):
      // From: https://gist.github.com/liabru/11263260#gistcomment-2894088
      function download(filename, text) {
        var element = document.createElement("a");
        element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(text));
        element.setAttribute("download", filename);

        element.style.display = "none";
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
      }

      // Dot tool functions:

      function create_temporary_dot(x, y) {
        var drawing = document.getElementById("drawing");
        var dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        dot.setAttribute("id", "ohm_dot");
        dot.setAttribute("cx", x);
        dot.setAttribute("cy", y);
        dot.setAttribute("r", "10");
        dot.setAttribute("stroke-width", "3");
        add_temporary_element(dot);
      }

      function update_temporary_dot(x, y) {
        var temporary_elements = get_temporary_elements();
        console.assert(temporary_elements.length == 1, temporary_elements);
        var dot = temporary_elements[0];
        dot.setAttribute("cx", x);
        dot.setAttribute("cy", y);
      }

      function drawing_dot_hover(x, y) {
        if (get_temporary_elements().length == 0) {
          create_temporary_dot(x, y);
        } else {
          update_temporary_dot(x, y);
        }
      }

      // Circle & pin tool functions:

      function find_circle(x, y) {
        var drawing = document.getElementById("drawing");

        for (let element of drawing.getElementsByTagName("circle")) {
          var cx = element.getAttribute("cx");
          var cy = element.getAttribute("cy");
          var classes = element.classList;
          if (!classes.contains("tmp") && cx === x && cy === y) {
            return element;
          }
        }
        return null;
      }

      function circle_exists(x, y) {
        return find_circle(x, y) != null;
      }

      function remove_circle(x, y) {
        if (circle_exists(x, y)) {
          find_circle(x, y).remove();
        }
      }

      function set_circle_small(circle) {
        circle.setAttribute("r", "10");
        circle.setAttribute("stroke-width", "3");
        circle.setAttribute("fill", "white");
        circle.setAttribute("stroke", "black");
      }

      function set_circle_radius(circle, radius) {
        circle.setAttribute("r", "" + radius);
        circle.setAttribute("stroke-width", "8");
        circle.setAttribute("fill", "none");
        circle.setAttribute("stroke", "black");
      }

      function create_temporary_circle(x, y) {
        var drawing = document.getElementById("drawing");
        var circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("id", "ohm_circle");
        circle.setAttribute("cx", x);
        circle.setAttribute("cy", y);
        set_circle_small(circle);
        add_temporary_element(circle);
      }

      function move_temporary_circle(x, y) {
        var temporary_elements = get_temporary_elements();
        console.assert(temporary_elements.length == 1, temporary_elements);
        var circle = temporary_elements[0];
        circle.setAttribute("cx", x);
        circle.setAttribute("cy", y);
      }

      function scale_temporary_circle(x, y) {
        var temporary_elements = get_temporary_elements();
        console.assert(temporary_elements.length == 1, temporary_elements);
        var circle = temporary_elements[0];
        var cx = circle.getAttribute("cx");
        var cy = circle.getAttribute("cy");
        var distance_squared = Math.pow(x - cx, 2) + Math.pow(y - cy, 2);
        var distance = Math.sqrt(distance_squared);
        if (distance < grid_size) {
          set_circle_small(circle);
          return;
        }
        set_circle_radius(circle, distance);
      }

      function drawing_circle_hover(x, y) {
        if (get_temporary_elements().length == 0) {
          create_temporary_circle(x, y);
        } else {
          move_temporary_circle(x, y);
        }
      }

      function drawing_circle_drag(x, y) {
        if (get_temporary_elements().length == 0) {
          return; // Mouse down event should create element, do nothing
        }
        scale_temporary_circle(x, y);
      }

      // Delete tool functions:

      function drawing_delete_mouse_down(event) {
        var elements = hovered_elements(event);

        for (let element of elements) {
          element.remove();
        }
      }

      function drawing_delete_hover(event) {
        set_class_for_hovered(event, "delete");
      }

      // Copy tool functions:

      function translate_element(element, x, y) {
        x = Number(x);
        y = Number(y);
        if (element.tagName === "circle") {
          var old_x = Number(element.getAttribute("cx"));
          var old_y = Number(element.getAttribute("cy"));
          element.setAttribute("cx", old_x + x);
          element.setAttribute("cy", old_y + y);
        } else if (element.tagName === "polygon" || element.tagName === "polyline") {
          var points = get_points(element);
          for (var i = 0; i < points.length; ++i) {
            points[i].x = Number(points[i].x) + x;
            points[i].y = Number(points[i].y) + y;
          }
          element.setAttribute("points", create_points_str(points));
        } else {
          alert("Cannot move this: " + element.tagName);
        }
      }

      function drawing_copy_hover(event) {
        var temporary_elements = get_temporary_elements();
        if (temporary_elements.length === 0) {
          // No click yet - Make hovered elemnts green:
          set_class_for_hovered(event, "copy");
        } else {
          // Temporary elements exist - translate them:

          var mouse_x = round_to_grid(event.offsetX);
          var mouse_y = round_to_grid(event.offsetY);

          var translate_x = mouse_x - translation.past.x;
          var translate_y = mouse_y - translation.past.y;

          for (let element of temporary_elements) {
            translate_element(element, translate_x, translate_y);
          }

          translation.past.x = mouse_x;
          translation.past.y = mouse_y;
        }
      }

      function drawing_copy_mouse_down(event) {
        var temporary_elements = get_temporary_elements();
        if (temporary_elements.length === 0) {
          // First click - create copies:
          var elements = hovered_elements(event);

          for (let element of elements) {
            add_temporary_element(element.cloneNode(true));
          }
          var mouse_x = round_to_grid(event.offsetX);
          var mouse_y = round_to_grid(event.offsetY);
          translation = {};
          translation.past = {};
          translation.past.x = mouse_x;
          translation.past.y = mouse_y;
        } else {
          // Second click - Place copies:
          place_temporary_elements();
          translation = null;
          drawing_copy_hover(event);
        }
      }

      // Wire tool functions:

      function get_points(polyline) {
        var points = polyline.getAttribute("points").split(" ");
        var results = [];
        for (let point of points) {
          var coordinates = point.split(",");
          var x = coordinates[0];
          var y = coordinates[1];
          results.push({
            x: x,
            y: y
          });
        }
        return results;
      }

      function create_points_str(points) {
        var string = "";
        for (let point of points) {
          string += "" + point.x + "," + point.y + " ";
        }
        return string.trim();
      }

      function drawing_wire_mouse_down(x, y) {
        if (get_temporary_elements().length === 0) {
          wire_start(x, y);
        } else {
          var temporary_elements = get_temporary_elements();
          console.assert(temporary_elements.length == 1, temporary_elements);
          var wire = get_temporary_elements()[0];
          var points = get_points(wire);

          // Get the first point and last point we clicked:
          var first = points[0];
          var last = points[points.length - 2]; // - 2 because - 1 is the hovering point

          // End the wire if you connected with the first, or clicked the same point twice:
          if ((first.x === x && first.y === y) || (last.x === x && last.y === y)) {
            wire_end();
          } else {
            wire_continue(x, y);
          }
        }
      }

      function drawing_wire_hover(x, y) {
        if (get_temporary_elements().length === 0) {
          return;
        }
        var wire = get_temporary_elements()[0];
        var points = get_points(wire);
        points[points.length - 1] = {
          x: x,
          y: y
        };
        wire.setAttribute("points", create_points_str(points));
        var replace_tag = null;
        if (points[0].x === x && points[0].y === y) {
          if (wire.tagName === "polyline") {
            replace_tag = "polygon";
          }
        } else {
          if (wire.tagName === "polygon") {
            replace_tag = "polyline";
          }
        }
        if (replace_tag) {
          var new_wire = create_wire(points, "", replace_tag);
          add_temporary_element(new_wire);
          wire.remove();
        }
      }

      function wire_start(x, y) {
        var point = {
          x: x,
          y: y
        };
        var points = [point, point];
        var polyline = create_wire(points, "", "polyline");
        add_temporary_element(polyline);
      }

      function wire_continue(x, y) {
        var point = {
          x: x,
          y: y
        };
        var wire = get_temporary_elements()[0];
        var points = get_points(wire);
        points.push(point);
        wire.setAttribute("points", create_points_str(points));
      }

      function wire_end() {
        place_temporary_elements();
      }

      function create_wire(points, id, tag) {
        var line = document.createElementNS("http://www.w3.org/2000/svg", tag);
        line.setAttribute("points", create_points_str(points));
        line.setAttribute("id", id);
        line.setAttribute("stroke-width", "8");
        line.setAttribute("fill", "none");
        line.setAttribute("stroke", "black");
        return line;
      }
    </script>
  </head>
  <body onload="init_ohm();">
    <div class="sidebar">
      <div class="sidebar_content">
        <h1 class="toolheader"><a href="https://github.com/olehermanse/ohm/">ohm</a></h1>
        <div id="toolbox" class="toolbox">
          <div title="Add wire" class="tool" id="wire" onclick="toolbar('wire');">
            <div class="tool_icon" data-feather="edit-2">Wire</div>
          </div>
          <div title="Add dot" class="tool" id="dot" onclick="toolbar('dot');">
            <div class="tool_icon" data-feather="circle">Dot</div>
          </div>
          <div title="Add circle" class="tool" id="circle" onclick="toolbar('circle');">
            <div class="tool_icon" data-feather="circle">Circle</div>
          </div>
          <div title="Add text" class="tool" id="text" onclick="toolbar('text');">
            <div class="tool_icon" data-feather="type">Text</div>
          </div>
          <div title="Copy" class="tool" id="copy" onclick="toolbar('copy');">
            <div class="tool_icon" data-feather="copy">Copy</div>
          </div>
          <div title="Delete object" class="tool" id="delete" onclick="toolbar('delete');">
            <div class="tool_icon" data-feather="x">Delete</div>
          </div>
          <div title="Save" class="tool" id="save" onclick="toolbar('save');">
            <div class="tool_icon" data-feather="save">Save</div>
          </div>
          <div title="Load" class="tool" id="load" onclick="toolbar('load');">
            <div class="tool_icon" data-feather="upload">Load</div>
          </div>
        </div>
      </div>
    </div>
    <svg id="drawing" width="720" height="720" xmlns="http://www.w3.org/2000/svg"></svg>
  </body>
  <script>
    feather.replace();

    function replace_dot() {
      var wrapper = document.getElementById("dot");
      for (let element of wrapper.children) {
        if (element.tagName === "svg") {
          element.setAttribute("fill", "currentColor");
          element.setAttribute("stroke", "none");
        }
      }
    }

    function replace_circle() {
      var wrapper = document.getElementById("circle");
      for (let element of wrapper.children) {
        if (element.tagName === "svg") {
          element.setAttribute("stroke", "currentColor");
        }
      }
    }

    replace_dot();
    replace_circle();
  </script>
</html>
